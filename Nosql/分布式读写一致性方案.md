### 理论依据

```
W + R > N

R > N - W
```

* N 代表副本数量
* W 代表同步写的副本数量
* R 代表读几个副本

### 高可用，一致性读写方案
大体思路类似于两阶段提交，但是是两阶段的变种，主要区别在于第二阶段为异步形式，且不算在Master的RT范围内。

### 专业术语

*     WO = Write Offset

    代表数据在这个节点上写到了哪里，全局递增，写入的数据不一定对应用可见。


*     CO = Commit Offset
    
    代表数据的可见性，<= CO的数据对APP可见，称之为已提交数据


*     临界数据 = WO - CO
    临界数据对应用不可见


### 具体场景描述如下

例如W=3， N=5， R=3时，Master收到Put(Key1, Value1)请求时，成功写入5个节点，由收到Put(Key1, Value2)时，这时，Master向另外4个Slave同时发起写请求，5个数据副本的状态变迁如下

**Master收到数据，向Slave发起写请求之前**

    M WO=100 CO=90
    
    S1 WO=90 CO=90
    
    S2 WO=90 CO=90
    
    S3 WO=90 CO=90
    
    S4 WO=90 CO=90


**场景一：发起请求之后
等待3s后，有W个节点返回成功
这时候直接给APP返回成功，并且异步向W个节点发起第二阶段提交**



    M WO=100 CO=100
    
    S1 WO=100 CO=100
    
    S2 WO=100 CO=90
    
    S3 WO=90 CO=90
    
    S4 WO=90 CO=90

**场景二：发起请求之后
等待3s后，有W-1个节点返回成功，这时候直接给用户返回类似于超时的异常，表示这条数据是否成功不确定，
所以Master的CO不增加**


    M WO=100 CO=90
    
    S1 WO=100 CO=90
    
    S2 WO=90 CO=90
    
    S3 WO=90 CO=90
    
    S4 WO=90 CO=90


**场景一可能遇到的问题**

向APP返回成功，这时候另外一个APP正在读，那么R=3， 例如读S2，S3，S4，
读出的数据取三个节点的最大版本，如果key1的最新值正好在WO-CO之间，那么我们认为这条数据虽然写成功，但是在这几个节点上还没有提交，那么需要再去Master上读一遍。
这里的核心思想是，Master上的数据为最新数据，且99%的读请求不可能读到 WO-CO之间，原因是刚写入立刻就读这种应用只占一部分，另外这个读过程中，很大程度上， 几个Slave都已经被提交了。

**场景二可能遇到的问题**

这时候给用户返回超时，可以理解为数据库执行sql向app返回超时，实际数据库有可能正在执行一个事务，数据被锁住。那么这时候，app只应该能看到key1的历史最新数据，而正在写入的数据不可见。一旦这个事务执行完成就可以见了。

当APP读S2，S3,S4时，很明确，读到的数据是Key1的上一个值

当APP读S1，S2，S3时，发现最新数据落到S1上，且数据属于临界数据，那么这时候，App自动从Master读数据，这时候，master的CO=90，所以Master会向APP返回Key1的上一个历史数据。


**以上做法可以解释所有W+R>N的场景，例如W=5，N=5，R=1， 这个对于读多写少非常有用，真正可以做到一致性，且读能力水平扩展，且写的性能不因为两阶段提交受太大影响。**























